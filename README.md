# shcb-test-main

## Слои-сцены и game-events
В проекте сохраняется подход слоёв-сцен путём загрузки сцен методом additive и передачи данных между сценами при помощи game events (плюс статическое значение для информации об энергопотреблении). Например, когда активируется элемент интерфейса, то посылает сигнал-евент в соответствии со своим индексом иерархии и нужный объект из другой сцены с назначенным ему соответствующим индексом "ловит" евент при совпадении индексов и выполняет присущие ему действия. Для выполнения этих действий используется дополнительный виртуальный объект, крепящийся к девайсу и содержащий специальные скрипты для использования девайса.

## Энергосеть
Данные действия доступны не всегда, их может ограничить второй виртуальный объект, прикрепляемый к каждому девайсу-узлу сети. Основное предназначение этого второго объекта - определять проведён ли ток в участок сети, где находится он и его девайс (в зависимости от скриптов для разных объектов могут быть вариации). Проведённость тока обычно определяется наличием активного элемента (=1) в листе, обозначенном в скрипте GridListScript родительского объекта. По значениям листа можно судить о количестве "заряженных" током входов. Среди вариаций скриптов сетевого объекта есть такие, которые передают значения заряженности дальше, объектам, обозначенным в публичных полях таких скриптов. Эти объекты должны быть следующими девайсами идущими в цепочке, т.е. быть соединёнными проводами с передающим объектом в сторону от источника энергии. Когда объекту переданы достаточное количество значений, равное количеству входов (устанавливается передающими скриптами автоматически при запуске сцены), запускается проверка на наличие проведённости тока через входы, и устанавливается наличие или отсутствие тока в получившем данные узле. Конечные устройства тратят ток источника напрямую подключаясь к нему из своих скриптов (на данный момент через публичное поле). Любое изменение в энергосети запускает обновление её состояния (инициализация в скрипте самого источника энергии). В момент обновления листы входов каждого узла сети сбрасываются, освобождая место для элементов, что последуют после обновления, сетевой подобъект отключается, чтобы иметь возможность вновь запустить свои операции при включении, а значение проведённости тока в узле сети обнуляется. После сброса ток от источника вновь начинает идти к подключенным к нему объектам и дальше через обработку скриптов сетевых объектов, вновь активируемых из предыдущих узлов сети. Через долю секунды также обновляем информацию об энергопотреблении, исходя из действий устройств сети и новых данных.

#### Дверь
Использует сразу два объекта действий. Когда отключается один, включается другой, и наоборот. Нужно для срабатывания операций скрипта DoorDriverScript при каждом запросе к двери.

#### Гейты
Имеют два входа, каждый из которых работает в сети подобно мосту. Соответственно публичное обращение из объектов должно идти ко входам, а не к самому гейту. И входы должны обращаться к выходу гейта, с сетевым объектом, скрипт которого зависит от типа гейта.

#### Время
Виджет псевдоприложения отображает текущее реальное время. Внутри приложения его можно ускорить или замедлить через интерфейс. Ход времени в самом приложении также меняется. Достигается посредством объявления переменной времени равной реальному времени на старте приложения и последующим прибавлением к этому времени значения Time.deltaTime в методе Update. По клику на элемент интерфейса меняем Time.timeScale соответственно.

#### Сброс сцены
Через событие от кнопки, загружаем из SceneManager нулевую(активную) сцену, а поскольку наш менеджер находится в активной сцене 0, то и остальные сцены перезагружаются, из-за вызова Start() при её загрузке, в котором и находятся команды на загрузку остальных сцен.

#### Камеры
В текущем проекте все камеры имеют объект с тегом MainCamera, работающий как камера. При запуске сцены формируется лист из этих объектов и включается только первый объект. По щелчку на ui текущая активная камера менятся на следующий элемент в списке камер (нулевой, если достигнут конец списка).

#### Робот-пылесос
Идея робота-пылесоса заключается в тщательной энергоэффективной уборке помещений. При запуске бота из приложения во время первой уборки бот знает только стартовую позицию и действует(должен действовать) следующим образом: проверяет клетку перед ним и две боковые на препятствия. Если препятствий нет, заносит позиции клеток в список приоритета определённым образом - к непройденным клеткам добавляется 2 приоритета, а клеткам перед ботом добавляется 1 приоритета. Робот в первую очередь идёт на клетки с наивысшим приоритетом. Таким образом он осуществляет уборку непройденных клеток, стараясь при движении тратить меньше энергии на лишнии повороты. Кейсов мало, поэтому значения присваиваемых клеткам приоритетов указываются в коде в ручную (сейчас хранится неудачная реализация с листом(приоритет) листов(клетка) листов координат). Посещённые клетки бот заносит в память и учитавает их в системе приоритетов и дальнейшей уборке. После первой уборки данные из памяти можно использовать для первостепенной уборки наиболее отдалённых от зарядки клеток, чтобы сэкономить энергию при возвращении на зарядную станцию(меньше ехать).
